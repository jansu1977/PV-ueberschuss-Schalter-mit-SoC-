blueprint:
  name: "PV‑Überschuss‑Schalter (SoC, Verzögerung, Prioritäten, Notify)"
  description: >
    **Funktionslogik**

    1. **Einschalten** (Schalter werden STUFE für STUFE aktiviert)
       * Akku‑SoC ≥ *Mindest‑SoC*  **und**
       * PV‑Überschuss ≥ *Mindest‑Überschuss* **für** *Überschuss‑Verzögerung* Sekunden.
       
       Dabei wird die Schalter‑Liste in der angegebenen Reihenfolge abgearbeitet.
       Für jede Stufe wird *Schalt‑Leistung* Watt zusätzlicher Überschuss
       vorausgesetzt, bevor der nächste Schalter aktiviert wird.

    2. **Betrieb**
       *Schalter bleiben an*, bis Akku‑SoC **unter** den Schwellenwert fällt.
       (PV‑Überschuss darf zwischendurch entfallen.)

    3. **Ausschalten** (mit Aus‑Verzögerung)
       * Akku‑SoC < *Mindest‑SoC* **für** *Aus‑Verzögerung* Sekunden → alle Schalter aus.

    4. **Benachrichtigung**
       Bei jedem Umschalten wird optional ein Notify‑Dienst aufgerufen.

    5. **Import‑Limit**
       Einschalten erfolgt nur, wenn der aktuelle Netz‑Import **unter** dem
       eingestellten Grenzwert liegt.

  domain: automation

  input:
    target_switches:
      name: Schalter‑Liste (Priorität = Reihenfolge)
      selector:
        entity:
          domain: switch
          multiple: true
    switch_step_power:
      name: Schalt‑Leistung je Stufe (W)
      default: 500
      selector:
        number:
          min: 50
          max: 5000
          step: 50
          unit_of_measurement: "W"
          mode: slider

    surplus_sensor:
      name: PV‑Überschuss‑Sensor (W)
      selector:
        entity:
          domain: sensor
    battery_soc_sensor:
      name: Batterie‑SoC‑Sensor (%)
      selector:
        entity:
          domain: sensor
    grid_import_sensor:
      name: Netz‑Import‑Sensor (W)
      selector:
        entity:
          domain: sensor
      default: ""  # optional

    min_soc_helper:
      name: Helper‑Entität Mindest‑SoC (input_number)
      selector:
        entity:
          domain: input_number
      default: ""
    min_surplus_helper:
      name: Helper‑Entität Mindest‑Überschuss (input_number)
      selector:
        entity:
          domain: input_number
      default: ""

    fallback_min_soc:
      name: Fallback Mindest‑SoC (%)
      default: 50
      selector:
        number:
          min: 0
          max: 100
          step: 1
          unit_of_measurement: "%"
    fallback_min_surplus:
      name: Fallback Mindest‑Überschuss (W)
      default: 500
      selector:
        number:
          min: -20000
          max: 20000
          step: 50
          unit_of_measurement: "W"

    surplus_delay:
      name: Überschuss‑Verzögerung EIN (s)
      default: 30
      selector:
        number:
          min: 0
          max: 600
          step: 5
          unit_of_measurement: "s"
    off_delay:
      name: Aus‑Verzögerung bei niedrigem SoC (s)
      default: 60
      selector:
        number:
          min: 0
          max: 600
          step: 5
          unit_of_measurement: "s"

    import_limit:
      name: Max. erlaubter Netz‑Import beim Einschalten (W)
      default: 0
      selector:
        number:
          min: 0
          max: 5000
          step: 50
          unit_of_measurement: "W"

    notify_service:
      name: Notify‑Dienst (optional)
      selector:
        text: {}
      default: ""

# --------------- VARIABLEN ----------------
variables:
  min_soc: >
    {{ states(min_soc_helper) | float if min_soc_helper else fallback_min_soc }}
  min_surplus: >
    {{ states(min_surplus_helper) | float if min_surplus_helper else fallback_min_surplus }}

trigger:
  - platform: state
    entity_id:
      - !input surplus_sensor
      - !input battery_soc_sensor
      - !input grid_import_sensor

# --------------- AKTION -------------------
action:
  - variables:
      pv: "{{ states('!input surplus_sensor') | float(0) }}"
      soc: "{{ states('!input battery_soc_sensor') | float(0) }}"
      grid_import: >
        {{ states('!input grid_import_sensor') | float(0) if grid_import_sensor else 0 }}

  - choose:
      # ------- EINschalten mit Verzögerung & Import‑Limit -------
      - conditions:
          - condition: template
            value_template: "{{ pv >= min_surplus }}"
            for:
              seconds: !input surplus_delay
          - condition: numeric_state
            entity_id: !input battery_soc_sensor
            above: "{{ min_soc }}"
          - condition: template
            value_template: "{{ grid_import <= !input import_limit }}"
        sequence:
          - service: homeassistant.turn_on
            data:
              entity_id: >
                {% set available = (pv - min_surplus) | int(0) %}
                {% set step = !input switch_step_power | int %}
                {% set max_on = (available // step) + 1 %}
                {% set switches = expand(!input target_switches) %}
                {% set to_turn = [] %}
                {% for s in switches[0:max_on] if s.state == 'off' %}
                  {% set to_turn = to_turn + [s.entity_id] %}
                {% endfor %}
                {{ to_turn | join(',') }}
          - if: "{{ notify_service }}"
            then:
              - service: "{{ notify_service }}"
                data:
                  message: "Miner‑Automatik: Schalter EIN (SoC={{ soc }}%, PV={{ pv }} W)"

      # ------- AUSschalten mit Aus-Verzögerung -------
      - conditions:
          - condition: numeric_state
            entity_id: !input battery_soc_sensor
            below: "{{ min_soc }}"
            for:
              seconds: !input off_delay
        sequence:
          - service: homeassistant.turn_off
            target:
              entity_id: !input target_switches
          - if: "{{ notify_service }}"
            then:
              - service: "{{ notify_service }}"
                data:
                  message: "Miner‑Automatik: Schalter AUS (SoC={{ soc }}%)"
    default: []

mode: restart
